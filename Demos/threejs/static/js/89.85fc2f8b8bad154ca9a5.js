(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{"3F3C":function(n,e,t){"use strict";var i=t("Womt"),o=t("RyHr"),r=function(){function n(){this.initScene(),this.initCamera(),this.initLight(),this.initObject(),this.initRenderer(),this.initControls(),this.animate()}return n.prototype.initScene=function(){this.scene=new i.Scene},n.prototype.initCamera=function(){this.winHeight=window.innerHeight-document.getElementById("app").getBoundingClientRect().top,this.camera=new i.PerspectiveCamera(60,window.innerWidth/this.winHeight,.1,1e3),this.camera.position.x=20,this.camera.position.y=-200,this.camera.position.z=20,this.camera.lookAt(new i.Vector3(0,0,0))},n.prototype.initLight=function(){this.light=new i.DirectionalLight(16777215,1),this.light.position.set(-80,60,40),this.light.shadow.camera.far=500,this.light.shadow.camera.near=20,this.light.shadow.camera.left=-50,this.light.shadow.camera.right=50,this.light.shadow.camera.top=50,this.light.shadow.camera.bottom=-50,this.light.castShadow=!0,this.scene.add(this.light)},n.prototype.initObject=function(){},n.prototype.initRenderer=function(){var n=this;this.renderer=new i.WebGLRenderer,this.renderer.setSize(window.innerWidth,this.winHeight),this.renderer.shadowMap.enabled=!0,document.getElementById("app").appendChild(this.renderer.domElement);var e=new MutationObserver((function(t){for(var i=0,o=t;i<o.length;i++){var r=o[i];if("childList"==r.type&&r.removedNodes.length>0){e.disconnect(),n.unload(),n.clear();break}}}));e.observe(document.getElementById("app"),{childList:!0}),window.addEventListener("resize",this.resize.bind(this),!1)},n.prototype.initControls=function(){this.controls=new o.a(this.camera,this.renderer.domElement)},n.prototype.animate=function(){this.renderer&&(this.controls.update(),this.renderer.render(this.scene,this.camera),requestAnimationFrame(this.animate.bind(this)))},n.prototype.resize=function(){this.renderer&&(this.winHeight=window.innerHeight-document.getElementById("app").getBoundingClientRect().top,this.camera.aspect=window.innerWidth/this.winHeight,this.camera.updateProjectionMatrix(),this.renderer.setSize(window.innerWidth,this.winHeight))},n.prototype.clear=function(){cancelAnimationFrame(this.animate.bind(this)),this.controls.dispose(),this.scene.dispose(),this.renderer.dispose(),this.renderer.forceContextLoss(),this.renderer=null,this.scene=null,window.removeEventListener("resize",this.resize.bind(this),!1)},n.prototype.unload=function(){console.log("unload")},n}();e.a=r},S16z:function(n,e,t){"use strict";t.r(e);var i,o=t("Womt"),r=t("3F3C"),a=t("RyHr"),c=undefined&&undefined.__extends||(i=function(n,e){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)e.hasOwnProperty(t)&&(n[t]=e[t])})(n,e)},function(n,e){function t(){this.constructor=n}i(n,e),n.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}),s=function(n){function e(){return n.call(this)||this}return c(e,n),e.prototype.initLight=function(){},e.prototype.initCamera=function(){this.winHeight=window.innerHeight-document.getElementById("app").getBoundingClientRect().top,this.camera=new o.PerspectiveCamera(30,window.innerWidth/this.winHeight,1,1e4),this.camera.position.set(20,10,20)},e.prototype.initObject=function(){var n=new o.PlaneBufferGeometry(window.innerWidth,this.winHeight,40),e=new o.ShaderMaterial({vertexShader:"void main()\t{\n      gl_Position = vec4( position, 1.0 );\n    }",fragmentShader:"uniform float iGlobalTime;\n    uniform vec2 iResolution;\n  \n    const int NUM_STEPS = 8;\n    const float PI\t \t= 3.1415;\n    const float EPSILON\t= 1e-3;\n    float EPSILON_NRM\t= 0.1 / iResolution.x;\n  \n    // sea variables\n    const int ITER_GEOMETRY = 3;\n    const int ITER_FRAGMENT = 5;\n    const float SEA_HEIGHT = 0.6;\n    const float SEA_CHOPPY = 1.0;\n    const float SEA_SPEED = 1.0;\n    const float SEA_FREQ = 0.16;\n    const vec3 SEA_BASE = vec3(0.1,0.19,0.22);\n    const vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\n    float SEA_TIME = iGlobalTime * SEA_SPEED;\n    mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n  \n    mat3 fromEuler(vec3 ang) {\n      vec2 a1 = vec2(sin(ang.x),cos(ang.x));\n      vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n      vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n      mat3 m;\n      m[0] = vec3(\n        a1.y*a3.y+a1.x*a2.x*a3.x,\n        a1.y*a2.x*a3.x+a3.y*a1.x,\n        -a2.y*a3.x\n      );\n      m[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n      m[2] = vec3(\n        a3.y*a1.x*a2.x+a1.y*a3.x,\n        a1.x*a3.x-a1.y*a3.y*a2.x,\n        a2.y*a3.y\n      );\n      return m;\n    }\n  \n    float hash( vec2 p ) {\n      float h = dot(p,vec2(127.1,311.7));\t\n      return fract(sin(h)*43758.5453123);\n    }\n  \n    float noise( in vec2 p ) {\n      vec2 i = floor(p);\n      vec2 f = fract(p);\t\n      vec2 u = f * f * (3.0 - 2.0 * f);\n      return -1.0 + 2.0 * mix(\n        mix(\n          hash(i + vec2(0.0,0.0)\n        ), \n        hash(i + vec2(1.0,0.0)), u.x),\n        mix(hash(i + vec2(0.0,1.0) ), \n        hash(i + vec2(1.0,1.0) ), u.x), \n        u.y\n      );\n    }\n  \n    float diffuse(vec3 n,vec3 l,float p) {\n      return pow(dot(n,l) * 0.4 + 0.6,p);\n    }\n  \n    float specular(vec3 n,vec3 l,vec3 e,float s) {    \n      float nrm = (s + 8.0) / (3.1415 * 8.0);\n      return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n    }\n  \n    vec3 getSkyColor(vec3 e) {\n      e.y = max(e.y, 0.0);\n      vec3 ret;\n      ret.x = pow(1.0 - e.y, 2.0);\n      ret.y = 1.0 - e.y;\n      ret.z = 0.6+(1.0 - e.y) * 0.4;\n      return ret;\n    }\n  \n  \n    float sea_octave(vec2 uv, float choppy) {\n      uv += noise(uv);         \n      vec2 wv = 1.0 - abs(sin(uv));\n      vec2 swv = abs(cos(uv));    \n      wv = mix(wv, swv, wv);\n      return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);\n    }\n  \n    float map(vec3 p) {\n      float freq = SEA_FREQ;\n      float amp = SEA_HEIGHT;\n      float choppy = SEA_CHOPPY;\n      vec2 uv = p.xz; \n      uv.x *= 0.75;\n  \n      float d, h = 0.0;    \n      for(int i = 0; i < ITER_GEOMETRY; i++) {        \n        d = sea_octave((uv + SEA_TIME) * freq, choppy);\n        d += sea_octave((uv - SEA_TIME) * freq, choppy);\n        h += d * amp;        \n        uv *= octave_m;\n        freq *= 1.9; \n        amp *= 0.22;\n        choppy = mix(choppy, 1.0, 0.2);\n      }\n      return p.y - h;\n    }\n  \n    float map_detailed(vec3 p) {\n        float freq = SEA_FREQ;\n        float amp = SEA_HEIGHT;\n        float choppy = SEA_CHOPPY;\n        vec2 uv = p.xz;\n        uv.x *= 0.75;\n  \n        float d, h = 0.0;    \n        for(int i = 0; i < ITER_FRAGMENT; i++) {        \n          d = sea_octave((uv+SEA_TIME) * freq, choppy);\n          d += sea_octave((uv-SEA_TIME) * freq, choppy);\n          h += d * amp;        \n          uv *= octave_m;\n          freq *= 1.9; \n          amp *= 0.22;\n          choppy = mix(choppy,1.0,0.2);\n        }\n        return p.y - h;\n    }\n  \n    vec3 getSeaColor(\n      vec3 p,\n      vec3 n, \n      vec3 l, \n      vec3 eye, \n      vec3 dist\n    ) {  \n      float fresnel = 1.0 - max(dot(n,-eye),0.0);\n      fresnel = pow(fresnel,3.0) * 0.65;\n  \n      vec3 reflected = getSkyColor(reflect(eye,n));    \n      vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n  \n      vec3 color = mix(refracted,reflected,fresnel);\n  \n      float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n      color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n  \n      color += vec3(specular(n,l,eye,60.0));\n  \n      return color;\n    }\n  \n    // tracing\n    vec3 getNormal(vec3 p, float eps) {\n      vec3 n;\n      n.y = map_detailed(p);    \n      n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n      n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n      n.y = eps;\n      return normalize(n);\n    }\n  \n    float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n      float tm = 0.0;\n      float tx = 1000.0;    \n      float hx = map(ori + dir * tx);\n  \n      if(hx > 0.0) {\n        return tx;   \n      }\n  \n      float hm = map(ori + dir * tm);    \n      float tmid = 0.0;\n      for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n        float hmid = map(p);\n        if(hmid < 0.0) {\n          tx = tmid;\n          hx = hmid;\n        } else {\n          tm = tmid;\n          hm = hmid;\n         }\n      }\n      return tmid;\n    }\n  \n    void main() {\n      vec2 uv = gl_FragCoord.xy / iResolution.xy;\n      uv = uv * 2.0 - 1.0;\n      uv.x *= iResolution.x / iResolution.y;    \n      float time = iGlobalTime * 0.3;\n  \n      // ray\n      vec3 ang = vec3(\n        sin(time*3.0)*0.1,sin(time)*0.2+0.3,time\n      );    \n      vec3 ori = vec3(0.0,3.5,time*5.0);\n      vec3 dir = normalize(\n        vec3(uv.xy,-2.0)\n      );\n      dir.z += length(uv) * 0.15;\n      dir = normalize(dir);\n  \n      // tracing\n      vec3 p;\n      heightMapTracing(ori,dir,p);\n      vec3 dist = p - ori;\n      vec3 n = getNormal(\n        p,\n        dot(dist,dist) * EPSILON_NRM\n      );\n      vec3 light = normalize(vec3(0.0,1.0,0.8)); \n  \n      // color\n      vec3 color = mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n        pow(smoothstep(0.0,-0.05,dir.y),0.3)\n      );\n  \n      // post\n      gl_FragColor = vec4(pow(color,vec3(0.75)), 1.0);\n    }",uniforms:{iGlobalTime:{type:"f",value:.1},iResolution:{type:"v2",value:new o.Vector2(window.innerWidth,this.winHeight)}}});this.obj=new o.Mesh(n,e),this.scene.add(this.obj),this.clock=new o.Clock},e.prototype.initControls=function(){this.controls=new a.a(this.camera,this.renderer.domElement),this.controls.enabled=!1},e.prototype.animate=function(){this.renderer&&(this.obj.material.uniforms.iGlobalTime.value+=this.clock.getDelta(),this.renderer.render(this.scene,this.camera),requestAnimationFrame(this.animate.bind(this)))},e}(r.a);e["default"]=s}}]);